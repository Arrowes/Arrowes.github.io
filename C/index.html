<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/128.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16.png">
  <link rel="mask-icon" href="/images/arrow.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangyujie.space","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C, C++, Cmake的相关入门学习笔记，项目地址：C-coding">
<meta property="og:type" content="article">
<meta property="og:title" content="C, C++, Cmake">
<meta property="og:url" content="https://wangyujie.space/C/index.html">
<meta property="og:site_name" content="Arrow的笔记本">
<meta property="og:description" content="C, C++, Cmake的相关入门学习笔记，项目地址：C-coding">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.gitmirror.com/Arrowes/Blog/main/images/Cedge.png">
<meta property="article:published_time" content="2023-05-09T01:43:00.000Z">
<meta property="article:modified_time" content="2024-02-27T14:01:26.470Z">
<meta property="article:author" content="Arrow">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.gitmirror.com/Arrowes/Blog/main/images/Cedge.png">

<link rel="canonical" href="https://wangyujie.space/C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C, C++, Cmake | Arrow的笔记本</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Arrow的笔记本" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Arrow的笔记本</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <a>
        <img class="custom-logo-image" src="/images/arrow.png" alt="Arrow的笔记本">
      </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wangyujie.space/C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Arrow">
      <meta itemprop="description" content="记录一些杂七杂八的东西">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arrow的笔记本">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C, C++, Cmake
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-09 09:43:00" itemprop="dateCreated datePublished" datetime="2023-05-09T09:43:00+08:00">2023-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-27 22:01:26" itemprop="dateModified" datetime="2024-02-27T22:01:26+08:00">2024-02-27</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>43 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>C, C++, Cmake的相关入门学习笔记，项目地址：<a target="_blank" rel="noopener" href="https://github.com/Arrowes/C-coding">C-coding</a></p>
<span id="more"></span>

<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p><a target="_blank" rel="noopener" href="https://img.anfulai.cn/bbs/94810/C%20Primer%20Plus(%E7%AC%AC%E5%85%AD%E7%89%88)%E4%B8%AD%E6%96%87%E7%89%88.pdf">C Primer Plus(第六版)中文版</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">&quot;read -p &#x27;Press Enter to continue...&#x27; var&quot;</span>);<span class="comment">//linux按任意键继续命令</span></span><br><span class="line">system(<span class="string">&quot;clear&quot;</span>);<span class="comment">//linux清屏操作</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>); <span class="comment">//windows请按任意键继续</span></span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);<span class="comment">//windows清屏操作</span></span><br></pre></td></tr></table></figure>




<hr>
<hr>
<h1 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h1><p><a target="_blank" rel="noopener" href="https://github.com/Arrowes/C-coding/blob/main/C%2B%2B/21%E5%A4%A9%E5%AD%A6%E9%80%9AC%2B%2B%E7%AC%AC8%E7%89%88%20%E9%AB%98%E6%B8%85%E5%AE%8C%E6%95%B4PDF.pdf">21天学通C++第8版</a></p>
<h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1.绪论"></a>1.绪论</h2><p>C++最初由 Bjarne Stroustroup 于 1979 年在贝尔实验室开发，旨在作为 C 语言的继任者。但不同于C 语言，C++是一种面向对象的语言，实现了继承、抽象、多态和封装等概念。<br>C++是一种中级编程语言，这意味着使用它既可以高级编程方式编写应用程序，又可以低级编程方式编写与硬件紧密协作的库。</p>
<p>构建可执行文件：编写代码(.cpp) &gt; 编译器(.o &#x2F; .obj) &gt; 链接器(.exe)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">//标准头文件，引入std::cout</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World!!&quot;</span> &lt;&lt; std::endl; <span class="comment">// &lt;&lt;：流插入运算符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//cout 是在名称空间 std 中定义的一个流, 用来显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>开发环境</strong>：Visual studio code + GCC compiler&#x2F;MinGW, 按F5 Choose <code>C/C++: g++.exe build and debug active file</code>, 将编译、链接并执行应用程序</p>
<h2 id="2-C-程序的组成部分"><a href="#2-C-程序的组成部分" class="headerlink" title="2.C++程序的组成部分"></a>2.C++程序的组成部分</h2><ul>
<li>预处理器编译指令 <code>#include</code><br> <code>#include &quot;...relative path to .\FileB&quot;</code>包含自定义头文件，<code>&lt;&gt;</code>用来包含自定义头文件 </li>
<li>程序主体 <code>main()</code><br>程序的起点，前面的int是一种标准化约定，表示返回类型为整数</li>
<li>返回值<br>在 C++中，除非明确声明了不返回值，否则函数必须返回一个值，根据约定，程序员在程序运行成功时返回 0，并在出现错误时返回−1</li>
</ul>
<p><strong>namespace名称空间</strong>：是给代码指定的名称，有助于降低命名冲突的风险，如<code>std::cout</code>:调用名称空间 std 中独一无二的 cout, 若要省略std::, 先加入<code>using namespace std</code></p>
<p><strong>注释</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">/* 跨行</span></span><br><span class="line"><span class="comment">   注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>cin 可用于从用户那里获取文本输入和数字输入<code>std::cin &gt;&gt; Variable1 &gt;&gt; Variable2; </code></p>
<h2 id="3-使用变量和常量"><a href="#3-使用变量和常量" class="headerlink" title="3.使用变量和常量"></a>3.使用变量和常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><code>VariableType VariableName = InitialValue;</code><br>变量类型向编译器指出了变量可存储的数据的性质，编译器将为变量预留必要的空间。变量名由程序员选择，它替代了变量值在内存中的存储地址;<br>函数内部声明的为<em>局部变量</em>，作用域为局部，被限定在声明它的函数内，函数结束后，将销毁所有局部变量，并归还它们占用的内存；在函数外部声明的则为<em>全局变量</em>。</p>
<p>命名约定：对于变量名，采用<em>骆驼拼写法</em>(firstNumber, 第一个单词的首字母采用小写)，而对于诸如函数名等其他元素，采用 <em>Pascal 拼写法</em>(MultiplyNumbers(), 函数名每个首字母都大写)。</p>
<p>编译器支持的常见 C++变量类型:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
<th>概念</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>true&#x2F;false</td>
<td>布尔变量</td>
</tr>
<tr>
<td>char</td>
<td>256个字符值</td>
<td>存储单字符,如’A’</td>
</tr>
<tr>
<td>unsigned short int</td>
<td>0～65535</td>
<td>占16位内存&#x3D;$2^{16}$&#x3D;65536</td>
</tr>
<tr>
<td>short int</td>
<td>–32768～32767</td>
<td>最高有效位（MSB）做符号位</td>
</tr>
<tr>
<td>unsigned long int</td>
<td>0～4294967295</td>
<td>$2^{32}$</td>
</tr>
<tr>
<td>long int</td>
<td>–2147483648～2147483647</td>
<td></td>
</tr>
<tr>
<td>int (16位)</td>
<td>–32768～32767</td>
<td></td>
</tr>
<tr>
<td>int (32位)</td>
<td>–2147483648～2147483647</td>
<td></td>
</tr>
<tr>
<td>unsigned int（16位）</td>
<td>0～65535</td>
<td></td>
</tr>
<tr>
<td>unsigned int（32位）</td>
<td>0～4294967295</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>1.2e–38～3.4e38</td>
<td>浮点数</td>
</tr>
<tr>
<td>double</td>
<td>2.2e–308～1.8e308</td>
<td>双精度浮点数</td>
</tr>
</tbody></table>
<p>sizeof 确定变量长度（字节）：<code>sizeof (int)</code><br>使用列表初始化避免缩窄转换错误：<code>int anotherNum&#123; largeNum &#125;;</code><br>关键字 auto 自动推断类型：<code>auto coinFlippedHeads = true</code><br>typedef 替换变量类型: <code>typedef unsigned int MYINT; </code></p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在 C++中，常量类似于变量，只是不能修改。</p>
<ul>
<li>字面常量：可以是任何类型：布尔型、整型、字符串等</li>
<li>使用关键字 const 将变量声明为常量(最实用): <code>const double pi = 22.0 / 7;</code></li>
<li>使用 constexpr 定义常量表达式: <code>constexpr double GetPi() &#123;return 22.0 / 7;&#125; </code></li>
<li>使用关键字 enum 声明枚举: 指定一组特定的取值，枚举量起始值默认为0</li>
<li><del>使用#define 定义常量：<code>#define pi 3.14286</code>, 已被摒弃</del></li>
</ul>
<p>务必确保变量名阐述了变量的用途。<br>务必对变量进行初始化，确保变量包含非随机的确定值；并使用列表初始化来避免缩窄转换错误。<br>不要将保留的 C++关键字用作变量名，因为这将导致程序无法通过编译。</p>
<h2 id="4-管理数组和字符串"><a href="#4-管理数组和字符串" class="headerlink" title="4.管理数组和字符串"></a>4.管理数组和字符串</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在 C++中，数组让您能够按顺序将一系列相同类型的数据存储到内存中。</p>
<p><strong>静态数组：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myNumbers [<span class="number">5</span>] = &#123;&#125;; <span class="comment">//声明一个包含 5 个 int 元素的数组，并将每个元素都初始化为零</span></span><br><span class="line"><span class="type">char</span> myCharacters [<span class="number">5</span>];  <span class="comment">//定义一个包含 5 个字符的数组</span></span><br><span class="line">Num = myNumbers [<span class="number">0</span>];    <span class="comment">//取出第一个元素 </span></span><br><span class="line">myNumbers [<span class="number">3</span>] = <span class="number">2023</span>;   <span class="comment">//重新赋值</span></span><br><span class="line"><span class="comment">//Bytes consumed by an array = sizeof(element-type) * Number of Elements </span></span><br><span class="line"><span class="comment">//务必初始化数组，否则其元素将包含未知值。使用数组时，务必确保在其边界内。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在 C++中，可在内存中模拟多维数组(但存储数组的内存是一维的)</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span> [<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;&#125;;  <span class="comment">//or &#123;0, 1, 2, 3, 4, 5&#125;</span></span><br><span class="line">Num1 = <span class="built_in">array</span> [<span class="number">0</span>][<span class="number">1</span>]  <span class="comment">//取出元素1</span></span><br></pre></td></tr></table></figure>
<p><strong>动态数组</strong> <code>std::vector</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">dynArray</span> <span class="params">(<span class="number">3</span>)</span>; <span class="comment">//这个矢量能动态地调整其长度，以存储更多数据，且无需初始化</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C 风格字符串（危险）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; </span><br><span class="line"><span class="comment">//等同于：</span></span><br><span class="line"><span class="type">char</span> sayHello[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sayHello</span><br><span class="line"><span class="comment">//空字符‘\0’,也被称为字符串结束字符，告诉编译器字符串到此结束。不算长度</span></span><br><span class="line"><span class="comment">//如果没有在字符数组末尾添加空字符，可能跨越字符数组的边界,被称为缓冲区溢出</span></span><br></pre></td></tr></table></figure>
<p><strong>C++字符串</strong>：使用 <code>std::string</code>:<br>使用 C++标准字符串是更高效、更安全的方式。不同于字符数组（C 风格字符串实现），std::string 是动态的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="built_in">string</span> <span class="title function_">greetString</span> <span class="params">(<span class="string">&quot;Hello std::string!&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-使用表达式、语句和运算符"><a href="#5-使用表达式、语句和运算符" class="headerlink" title="5.使用表达式、语句和运算符"></a>5.使用表达式、语句和运算符</h2><p>从本质上说，程序是一组按顺序执行的命令。这些命令为表达式和语句，使用运算符执行特定的计算或操作。</p>
<ul>
<li>语句：分号界定了语句的边界; 要将一条语句放到两行中，可在第一行末尾添加反斜杠<code>\</code>; 可使用花括号（{}）将多条语句组合在一起，以创建复合语句（语句块）</li>
<li>运算符：<ul>
<li><code>=</code> 赋值运算符，左值通常是内存单元，右值可以是内存单元的内容。</li>
<li><code>+ - * / %</code> 求模运算符%返回除法运算的余数，只能用于整数</li>
<li><code>++ --</code> 递增和递减运算符，分为前缀与后缀： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = ++num;  <span class="comment">//前缀，先＋再赋值</span></span><br><span class="line"><span class="type">int</span> num = num++;  <span class="comment">//后缀，先赋值再+</span></span><br></pre></td></tr></table></figure></li>
<li><code>== !=</code>   相等性检查的结果为布尔值，即 true 或 false, 1 &#x2F; 0</li>
<li><code>&lt; &gt; &lt;= &gt;=</code></li>
<li>逻辑运算符(返回布尔值)： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!  <span class="comment">//NOT 用于单个操作数，用于反转</span></span><br><span class="line">&amp;&amp; <span class="comment">//AND, 2true则true</span></span><br><span class="line">|| <span class="comment">//OR, 1true就true</span></span><br><span class="line">^  <span class="comment">//XOR异或，1true才true</span></span><br></pre></td></tr></table></figure></li>
<li>按位运算符（返回运算结果）：<code>~  &amp;  |  ^</code></li>
<li>移位运算符,用途之一是将数据乘以或除以 $2^n$ <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> halfNum = inputNum &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> quadrupleNum = inputNum &lt;&lt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li>复合赋值运算符,将运算结果赋给左边的操作数 <code>num1 += num2;</code></li>
<li>运算符 <code>sizeof</code>, 确定变量占用的内存量</li>
</ul>
</li>
</ul>
<p>运算符优先级,C++标准非常严格地指定了各种运算的执行顺序:<br><code>int myNumber = 10 * 30 + 20 – 5 * 5 &lt;&lt; 2;</code> 应写作 <code>int myNumber = ((10 * 30) – (5 * 5) + 20) &lt;&lt; 2;</code>，使用括号让代码和表达式易于理解</p>
<h2 id="6-控制程序流程"><a href="#6-控制程序流程" class="headerlink" title="6.控制程序流程"></a>6.控制程序流程</h2><h3 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h3><p><code>if...else</code>  条件不为0就被视为true<br><code>if...else if...else</code><br><code>switch-case</code>  条件处理,相比if-else-if结构化程度更高</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)   </span><br><span class="line">&#123; <span class="comment">//计算 expression 的值，并将其与每个 case 标签进行比较</span></span><br><span class="line"><span class="keyword">case</span> LabelA:   <span class="comment">//务必将枚举量用作 case 标签，以提高代码的可读性。</span></span><br><span class="line"> DoSomething; </span><br><span class="line"> <span class="keyword">break</span>;  <span class="comment">//退出当前代码块</span></span><br><span class="line"><span class="comment">// And so on... </span></span><br><span class="line"><span class="keyword">default</span>: </span><br><span class="line"> DoStuffWhenExpressionIsNotHandledAbove; </span><br><span class="line"> <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>?:</code> 条件运算符&#x2F;三目运算符, 相当于紧凑的 if-else 结构<br><code>(conditional expression evaluated to bool) ? expression1 if true : expression2  if false; </code></p>
<h3 id="循环执行"><a href="#循环执行" class="headerlink" title="循环执行"></a>循环执行</h3><p><code>goto</code>   (避免使用 goto，可防止代码不直观且难以维护。)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SomeFunction() </span><br><span class="line">&#123;  <span class="comment">//不推荐使用 goto 语句来编写循环</span></span><br><span class="line">Start: <span class="comment">// Called a label </span></span><br><span class="line"> CodeThatRepeats; </span><br><span class="line"> <span class="keyword">goto</span> Start; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><code>while</code> 只要条件为 true，就将反复执行该语句块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(expression) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// Expression evaluates to true </span></span><br><span class="line"> StatementBlock; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>do...while</code> 循环逻辑至少执行一次时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123; </span><br><span class="line"> StatementBlock; <span class="comment">// executed at least once </span></span><br><span class="line">&#125; <span class="keyword">while</span>(condition); <span class="comment">// ends loop if condition evaluates to false </span></span><br></pre></td></tr></table></figure>
<p><code>for</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化语句 executed only once;  <span class="comment">//迭代器</span></span><br><span class="line"> 条件表达式 executed at the beginning of every loop; </span><br><span class="line"> 修改变量 executed at the end of every loop) </span><br><span class="line">&#123; <span class="comment">//以上三项都是可选的</span></span><br><span class="line"> DoSomething; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++11引入了<em>基于范围的 for 循环</em>，让对一系列值（如数组包含的值）进行操作的代码更容易编写和理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> charArray[] = &#123; <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span> &#125;; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> aChar : charArray) </span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; aChar &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//h e l l o </span></span><br></pre></td></tr></table></figure>
<p><code>continue</code> 能够跳转到循环开头，跳过循环块中后面的代码;<br><code>break</code> 退出循环块，即结束当前循环。</p>
<p>控制无限循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) <span class="comment">// no condition supplied = unending for </span></span><br><span class="line">&#123; </span><br><span class="line"> DoSomethingRepeatedly; </span><br><span class="line"> <span class="keyword">if</span>(expression) </span><br><span class="line"> <span class="keyword">break</span>; <span class="comment">// 使用 break 退出无限 for 循环</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="7-使用函数组织代码"><a href="#7-使用函数组织代码" class="headerlink" title="7.使用函数组织代码"></a>7.使用函数组织代码</h2><p>函数让您能够划分和组织程序的执行逻辑。通过使用函数，可将应用程序的内容划分成依次调用的逻辑块。</p>
<ul>
<li>声明函数原型<br><code>double Area(double radius)</code> &#x3D; 返回值类型 函数名(函数接受的参数列表)<br>函数可接受用逗号分隔的多个参数，但只能有一种返回类型。可以给多个参数指定默认值，但这些参数<em>必须位于参数列表的末尾</em>。</li>
<li>定义函数<br>函数定义由一个语句块组成。除非返回类型被声明为 void，否则函数必须包含一条 return 语句;</li>
<li>调用函数<br>如果函数声明中包含形参（parameter），调用函数时必须提供实参（argument）</li>
</ul>
<p>递归函数：调用自己，必须有明确的退出条件<br>多条 return 语句的函数：可使用 return 语句退出</p>
<h3 id="函数数据处理"><a href="#函数数据处理" class="headerlink" title="函数数据处理"></a>函数数据处理</h3><p>函数重载：名称和返回类型相同，但参数不同的函数被称为重载函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">Area</span><span class="params">(<span class="type">double</span> radius)</span>; <span class="comment">// for circle </span></span><br><span class="line"><span class="type">double</span> <span class="title function_">Area</span><span class="params">(<span class="type">double</span> radius, <span class="type">double</span> height)</span>; <span class="comment">// for cylinder</span></span><br><span class="line"><span class="comment">//根据不同的输入使用不同的函数，实现不同的功能</span></span><br></pre></td></tr></table></figure>
<p>数组传递给函数: <code>void DisplayIntegers(int[] numbers, int Length); </code></p>
<p><code>&amp;</code> 按引用传递参数, 让函数修改的变量在其外部（如调用函数）中也可用(详见第八章引用)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Area</span><span class="params">(<span class="type">double</span> radius, <span class="type">double</span> &amp;result)</span> </span><br><span class="line"><span class="comment">//此时，result是指向调用函数中相应变量的引用，而不是其拷贝</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>：...</span><br><span class="line">   <span class="title function_">Area</span><span class="params">(radius, areaFetched)</span>; </span><br><span class="line"><span class="comment">//Area( )中的变量 result，与 main( )中的 double areaFetched 指向同一个内存单元。</span></span><br></pre></td></tr></table></figure>
<h3 id="微处理器如何处理函数调用"><a href="#微处理器如何处理函数调用" class="headerlink" title="微处理器如何处理函数调用"></a>微处理器如何处理函数调用</h3><p><em>函数调用</em> 在微处理器中的过程：跳转到属于被调用函数的下一条指令处执行。执行完函数的指令后，返回到最初<em>离开的地方</em>;<br>因此，编译器将函数调用转换为一条供微处理器执行的 <code>CALL</code> 指令, 指出接下来要获取的指令所在的地址，该地址归函数所有。遇到 <code>CALL</code> 指令时，微处理器将调用函数后将要执行的指令的位置保存到 <strong>栈</strong> 中，再跳转到 <code>CALL</code> 指令包含的内存单元处。</p>
<blockquote>
<p>栈是一种后进先出的内存结构，将数据加入栈被称为压入操作, 从栈中取出数据被称为弹出操作。栈增大时，栈指针将不断递增，始终指向栈顶;<br>栈的性质使其非常适合用于处理函数调用。函数被调用时，所有局部变量都在栈中实例化，即被压入栈中。函数执行完毕时，这些局部变量都从栈中弹出，栈指针返回到原来的地方。<br>如：微处理器执行CALL指令指出的内存单元包含属于函数的指令，直到 RET 语句（return 语句对应的微处理器代码）导致微处理器从栈中弹出执行 CALL 指令时存储的地址。该地址包含调用函数中接下来要执行的语句的位置</p>
</blockquote>
<p><strong>内联函数</strong><br>使用关键字 inline 发出请求，要求在函数被调用时就地展开它们：<code>inline double GetPi() </code> 编译器通常将该关键字视为请求，请求将函数 GetPi()的内容直接放到调用它的地方，以提高代码的执行速度(因为执行函数调用的开销可能非常高)，仅当函数非常简单，需要降低其开销时，才应使用该关键字<br>(根据性能设置，大多数较新的编译器都能判断应内联哪些函数，进而为程序员这样做)</p>
<p><strong>自动推断返回类型</strong>: <code> auto Area(double radius)</code></p>
<p><strong>lambda 函数</strong>: <code>[optional parameters](parameter list)&#123; statements; &#125; </code><br>lambda函数是 C++11 引入的，有助于使用 STL 算法对数据进行排序或处理，可以在需要函数对象的地方使用，用于简化代码和提高可读性。</p>
<h2 id="8-阐述指针和引用"><a href="#8-阐述指针和引用" class="headerlink" title="8.阐述指针和引用"></a>8.阐述指针和引用</h2><p>C++最大的优点之一是，既可使用它来编写不依赖于机器的高级应用程序，又可使用它来编写与硬件紧密协作的应用程序。能够在字节和比特级调整应用程序的性能。要编写高效地利用系统资源的程序，理解<em>指针和引用</em>是必不可少的一步。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针 *"></a>指针 *</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1et411b73Z?p=56">指针_黑马</a></p>
<p><strong>指针就是地址，是存储内存地址的变量</strong>，是一种指向内存单元的特殊变量。<br>（内存单元地址通常使用十六进制表示法）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pointsToInt = <span class="literal">NULL</span>;  <span class="comment">//空指针，声明指针并初始化，务必初始化指针变量，否则它将包含垃圾值。空指针无法访问</span></span><br><span class="line"><span class="comment">//例如int在内存中的地址为0x002EFB34，则占用 0x002EFB34～0x002EFB37</span></span><br><span class="line"><span class="comment">//32位系统中指针占4字节，64位系统中占8字节，无论什么数据类型</span></span><br><span class="line">&amp;pointsToInt      <span class="comment">//引用运算符（&amp;）, 也叫地址运算符，用来获取变量的地址。</span></span><br><span class="line"><span class="type">int</span> * pointsToInt = &amp;age;  <span class="comment">//使用指针存储地址(age是int变量)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dogsAge = <span class="number">9</span>; </span><br><span class="line">pointsToInt = &amp;dogsAge;    <span class="comment">//同一个 int 指针可指向任何 int 变量</span></span><br><span class="line"></span><br><span class="line">++pointsToInt     <span class="comment">//将指向下一个int, Address + sizeof(int)</span></span><br><span class="line">*pointsToInt               <span class="comment">//解引用        运算符（*）,也叫间接运算符, 访问指向的数据</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; *pointsToInt;       <span class="comment">//使用 * 修改数据</span></span><br></pre></td></tr></table></figure>
<p><strong>动态内存分配 new delete</strong><br>静态数组的长度是固定的，不能根据应用程序的需求增大或缩小, 因此使用 new 和 delete 动态地分配和释放内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pointToAnInt = new <span class="type">int</span>;  <span class="comment">//给整型分配内存（int* Pointer = new int[10]; 为一系列元素分配内存</span></span><br><span class="line">delete pointToAnInt;          <span class="comment">//释放内存（delete[] Pointer; </span></span><br><span class="line"><span class="comment">//如果不释放，会造成内存泄露</span></span><br></pre></td></tr></table></figure>
<p>运算符 new 和 delete 分配和释放自由存储区中的内存。自由存储区是一种内存抽象，表现为一个内存池，应用程序可分配（预留）和释放其中的内存。</p>
<p><strong>将关键字 const 用于指针</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Age=<span class="number">23</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> point = &amp;Age;         <span class="comment">//指针包含的地址是常量，不能修改，但可修改指针指向的数据</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * point = &amp;Age;         <span class="comment">//指针指向的数据为常量，不能修改，但可以修改指针包含的地址，即指针可以指向其他地方</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> point = &amp;Age;   <span class="comment">//指针包含的地址以及它指向的值都是常量，不能修改（这种组合最严格）</span></span><br><span class="line"><span class="comment">//函数参数应声明为最严格的 const 指针</span></span><br><span class="line"><span class="comment">//**将指针传递给函数**: 指针是一种将内存空间传递给函数的有效方式，其中可包含函数完成其工作所需的数据，也可包含操作结果。</span></span><br></pre></td></tr></table></figure>
<p>数组变量是指向第一个元素的指针, 类似于在固定内存范围内发挥作用的指针，因此也可将用于指针的解除引用运算符（*）用于数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> * p = arr;  <span class="comment">//指向1，数组名就是数组首地址arr[0 ]</span></span><br><span class="line">p++;  <span class="comment">//指针后移4个字节，指向2</span></span><br></pre></td></tr></table></figure>
<p><strong>指针和函数</strong>，地址传递可以修饰实参,值传递不改变实参</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以交换数字为例</span></span><br><span class="line"><span class="comment">//1.值传递，形参不会修饰实参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>   </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> temp=a;</span><br><span class="line">   a=b;</span><br><span class="line">   b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.地址传递，形参会修饰实参</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap1</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> * p2)</span>   </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> temp=*p1;</span><br><span class="line">   *p1=*p2;</span><br><span class="line">   *p2=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">   swap1(a,b);    <span class="comment">//不改变实参</span></span><br><span class="line">   swap2(&amp;a,&amp;b);  <span class="comment">//改变实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用指针相关错误</strong></p>
<ul>
<li>内存泄漏：new动态分配的内存没有用delete释放</li>
<li>无效指针（野指针）：务必确保指针指向了有效的内存单元, 否则使用 * 和 delete 时会崩溃</li>
<li>悬浮指针：使用 delete 释放后，任何有效指针都将无效，很多程序员在初始化指针或释放指针后将其设置为 NULL，并在使用运算符 * 对指针解除引用前检查它是否有效（将其与 NULL 比较）</li>
<li>new内存分配失败：大块内存分配请求不一定能成功，失败会引发 <code>std::bad_alloc</code> 异常并中断执行<br>（<code>try-catch</code> 异常处理结构让程序能够向用户指出这一点，再正常退出；或可使用 new 变种 <code>new(nothrow)</code>，在内存分配失败时不引发异常，而返回 NULL，让您能够在使用指针前检查其有效性）</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用 &amp;"></a>引用 &amp;</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1et411b73Z?p=89&vd_source=b530b63b4657d68926b54a618d047d04">引用_黑马</a></p>
<p>作用：给变量起<strong>别名</strong><br>语法：<code>数据类型 &amp;别名 = 原名</code></p>
<p>引用运算符（&amp;）, 也叫地址运算符，用来获取变量的地址。<br>引用是变量的别名，只是另一种访问相应变量存储的数据的方式。直接调用，避免将形参复制给形参，减少复制步骤的开销，极大地提高性能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> original = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> &amp; ref = original; <span class="comment">//指向相应变量所在的内存单元,引用必须要初始化，且之后不可更改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可避免复制步骤的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DoSomething</span><span class="params">(<span class="type">int</span> &amp;a)</span>;     <span class="comment">//a 不再是 b 的拷贝，而是它的别名</span></span><br><span class="line"><span class="type">int</span> Result = DoSomething(b);  <span class="comment">//b 是按引用传递的</span></span><br><span class="line"><span class="comment">//函数直接使用调用者栈中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>&amp; ref=<span class="number">10</span> <span class="comment">//错误，引用需要合法的内存空间</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = original;  <span class="comment">//常量引用，使禁止通过引用修改它指向的变量的值，用来修饰形参，避免误操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetSquare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; number, <span class="type">int</span>&amp; result)</span>  <span class="comment">//const 引用将参数标识为输入参数，防止函数内部误改</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetSquare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> number, <span class="type">int</span>* <span class="type">const</span> result)</span>  <span class="comment">//效果同上，但指针不同于引用，可能为 NULL 或无效，因此使用前必须核实它们是有效的</span></span><br></pre></td></tr></table></figure>
<p>引用做函数参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.引用传递, 形参会修饰实参，且比用指针地址传递简单</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap3</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">   <span class="type">int</span> temp=a;</span><br><span class="line">   a=b;</span><br><span class="line">   b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用做函数返回值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> a=<span class="number">20</span>;  <span class="comment">//静态变量，不能返回局部变量的引用，会被释放</span></span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">int</span>&amp; ref=test();   <span class="comment">//ref=20</span></span><br><span class="line">   <span class="comment">//如果函数返回值是引用，则该函数调用可以作为左值</span></span><br><span class="line">   test()=<span class="number">10</span>;      <span class="comment">//ref=10,因为test返回值=a, ref=a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用的本质是一个指针常量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; ref=a; <span class="comment">//内部： int* const ref=&amp;a;</span></span><br><span class="line">ref=<span class="number">20</span>;     <span class="comment">//内部：*ref=20;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-类和对象"><a href="#9-类和对象" class="headerlink" title="9.类和对象"></a>9.类和对象</h2><p><u>现在开始面向对象</u></p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>将一系列数据和函数整合在一起的结构就是<strong>类</strong>,让您能够创建自己的数据类型，并在其中封装属性和使用它们的函数。<br>(<em>封装指的是将数据以及使用它们的函数进行逻辑编组，这是面向对象编程的重要特征</em>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明类, 使用关键字class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="built_in">string</span> name;</span><br><span class="line">   <span class="built_in">string</span> age;</span><br><span class="line">   <span class="type">void</span> <span class="title function_">Talk</span><span class="params">()</span></span><br><span class="line">   ...</span><br><span class="line">&#125;；         <span class="comment">// ;结尾</span></span><br></pre></td></tr></table></figure>

<p>在程序执行阶段，<strong>对象</strong>是类的化身。要使用类的功能，通常需要创建其实例—对象，并通过对象访问成员方法和属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 Human 的对象</span></span><br><span class="line">Human Man;  <span class="comment">//Man是Human类的对象，是运行阶段的化身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可使用 new 为 Human 对象动态地分配内存</span></span><br><span class="line">Human* Woman = new Human(); <span class="comment">// 分配内存并初始化为 Human 类的对象</span></span><br><span class="line">delete Woman; <span class="comment">// 在不再使用时释放内存</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>句点运算符 (.) 用于访问对象的属性</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Man.age= <span class="string">&quot;23&quot;</span>;</span><br><span class="line">Man.Talk();</span><br><span class="line"></span><br><span class="line">Human* Woman = new Human(); </span><br><span class="line">(*Woman).Talk();  <span class="comment">//使用解引用指针操作符 *，将指针 Woman 指向的地址解引用，获取指向的 Human 对象。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针运算符（-&gt;）访问成员</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Human* Woman = new Human(); </span><br><span class="line">Woman-&gt;age = <span class="string">&quot;22&quot;</span>;</span><br><span class="line">Woman-&gt;Talk(); <span class="comment">// 更简洁的写法，直接通过指针调用成员函数</span></span><br><span class="line">delete Woman;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">   <span class="built_in">string</span> name;</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line">   <span class="type">void</span> <span class="title function_">Talk</span><span class="params">()</span></span><br><span class="line">   &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am &quot;</span> + name &lt;&lt;<span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt;   <span class="string">&quot; years old&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   Human Man;</span><br><span class="line">   Man.name = <span class="string">&quot;wyj&quot;</span>;</span><br><span class="line">   Man.age = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">   Human Woman;</span><br><span class="line">   Woman.name = <span class="string">&quot;girl&quot;</span>;</span><br><span class="line">   Woman.age = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">   Man.Talk();</span><br><span class="line">   Woman.Talk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line">I am wyj, <span class="number">23</span> years old</span><br><span class="line">I am girl, <span class="number">22</span> years old</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="关键字-public-和-private"><a href="#关键字-public-和-private" class="headerlink" title="关键字 public 和 private"></a>关键字 public 和 private</h3><p>在面向对象编程语言中，抽象是一个非常重要的概念, 作为类的设计者，使用 C++关键字 public 和 private 来指定哪些部分可从外部（如 main( )）访问，哪些部分不能。<br>private私有属性和方法，访问和修改的唯一的途径就是通过类的public公有方法，这个以编写类的程序员认为的合适方式暴露。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">private:</span><br><span class="line">   <span class="type">int</span> age; </span><br><span class="line"></span><br><span class="line">public: </span><br><span class="line">   <span class="type">void</span> <span class="title function_">SetAge</span><span class="params">(<span class="type">int</span> humansAge)</span> </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">if</span> (humansAge &gt; <span class="number">0</span>) </span><br><span class="line">      age = humansAge; </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">GetAge</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(age &gt; <span class="number">30</span>)</span><br><span class="line">         <span class="keyword">return</span>(age - <span class="number">2</span>)   <span class="comment">//隐藏实际数据</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">return</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是一种特殊的函数，它与类同名且不返回任何值，在实例化对象时被调用。</p>
<p><strong>声明和实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类声明中实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">public: </span><br><span class="line">   Human()  </span><br><span class="line">   &#123; </span><br><span class="line">   <span class="comment">// constructor code here </span></span><br><span class="line">   &#125; </span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类声明外实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">public: </span><br><span class="line"> Human(); <span class="comment">// constructor declaration </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// constructor implementation (definition) </span></span><br><span class="line">Human::Human() <span class="comment">//::被称为作用域解析运算符。例如，Human::dateOfBirth 指的是在 Human 类中声明的变量 dateOfBirth，而::dateOfBirth 表示全局作用域中的变量 dateOfBirth</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// constructor code here </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造函数总是在创建对象时被调用</strong>，这让构造函数是将类成员变量（int、指针等）<strong>初始化为选定值</strong>的理想场所。<br>与函数一样，构造函数也可重载，创建对象时提供不同的参数会调用不同的构造函数，（<em>可在不提供参数的情况下调用的构造函数被称为<strong>默认构造函数</strong></em>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">private: </span><br><span class="line"> <span class="built_in">string</span> name; </span><br><span class="line"> <span class="type">int</span> age; </span><br><span class="line"></span><br><span class="line">public: </span><br><span class="line"> Human(<span class="built_in">string</span> humansName, <span class="type">int</span> humansAge = <span class="number">25</span>) </span><br><span class="line"> &#123; </span><br><span class="line"> name = humansName; </span><br><span class="line"> age = humansAge; </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Overloaded constructor creates &quot;</span> &lt;&lt; name; </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; of age &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// ... other members </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化这个类时，可使用下面的语法：</span></span><br><span class="line">Human <span class="title function_">adam</span><span class="params">(<span class="string">&quot;Adam&quot;</span>)</span>; <span class="comment">// adam.age is assigned a default value 25 </span></span><br><span class="line">Human <span class="title function_">eve</span><span class="params">(<span class="string">&quot;Eve&quot;</span>, <span class="number">18</span>)</span>; <span class="comment">// eve.age is assigned 18 as specified</span></span><br></pre></td></tr></table></figure>
<p>另一种初始化成员的方式是使用<strong>初始化列表</strong>, 冒号后面列出了各个成员变量及其初始值, 可以将上下代码对比着看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">private: </span><br><span class="line"> <span class="built_in">string</span> name; </span><br><span class="line"> <span class="type">int</span> age; </span><br><span class="line"></span><br><span class="line">public: </span><br><span class="line"> <span class="comment">// two parameters to initialize members age and name </span></span><br><span class="line"> Human(<span class="built_in">string</span> humansName, <span class="type">int</span> humansAge) </span><br><span class="line"> :name(humansName), age(humansAge) </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Constructed a human called &quot;</span> &lt;&lt; name; </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; <span class="string">&quot; years old&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// ... other class members </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>也是一种特殊的函数，与类同名，但前面有一个腭化符号（～）<br>构造函数在实例化对象时被调用，而析构函数在<strong>对象销毁时</strong>自动被调用。</p>
<p><strong>声明和实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类声明中实现（定义）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">public: </span><br><span class="line"> ~Human() </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="comment">// destructor code here </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//在类声明外定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">public: </span><br><span class="line"> ~Human(); <span class="comment">// destructor declaration </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">Human::~Human() </span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// destructor code here </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>每当对象不再在作用域内或通过 delete 被删除进而被销毁时，都将调用析构函数。这使得析构函数成为<em>重置</em>变量以及<em>释放</em>动态分配的内存和其他资源的理想场所<br>如：某个类中，在构造函数中new, 在析构函数中delete, 使该类不仅对程序员隐藏了内存管理实现，还正确地释放了分配的内存。<br>（<em>析构函数不能重载</em>）</p>
<h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>浅复制的问题：<em>复制类的对象时</em>，将复制其指针成员，但不复制指针指向的缓冲区，其结果是两个对象指向同一块动态分配的内存。销毁其中一个对象时，delete[]释放这个内存块，导致另一个对象存储的指针拷贝无效。这种复制被称为浅复制，会威胁程序的稳定性</p>
<p>因此使用复制构造函数确保<em>深复制</em>，这是一个重载的构造函数，每当<strong>对象被复制时</strong>，编译器都将调用复制构造函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">   private:...</span><br><span class="line">   public:</span><br><span class="line">   MyString(<span class="type">const</span> <span class="type">char</span>* initString)</span><br><span class="line">   ...</span><br><span class="line">   MyString(<span class="type">const</span> MyString&amp; copySource) <span class="comment">// copy constructor </span></span><br><span class="line">   &#123;  <span class="comment">//使用 const，可确保复制构造函数不会修改指向的源对象</span></span><br><span class="line">   <span class="comment">// Copy constructor implementation code </span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//以确保在main中函数调用时进行深复制</span></span><br><span class="line">MyString <span class="title function_">sayHello</span><span class="params">(<span class="string">&quot;Hello world！&quot;</span>)</span>;</span><br><span class="line">UseMyString(sayHello);  <span class="comment">//自动调用复制构造函数</span></span><br></pre></td></tr></table></figure>
<p>(<em>类包含原始指针成员（char* 等）时，务必编写复制构造函数和复制赋值运算符。<br>务必将类成员声明为 std::string 和智能指针类（而不是原始指针），因为它们实现了复制构造函数，可减少工作量。</em>)</p>
<p>移动构造函数 <code>MyString(MyString&amp;&amp; moveSource) </code>：编译器将自动使用它来“移动”临时资源，从而避免深复制</p>
<h3 id="构造函数和析构函数的其他用途"><a href="#构造函数和析构函数的其他用途" class="headerlink" title="构造函数和析构函数的其他用途"></a>构造函数和析构函数的其他用途</h3><p>禁止类对象被复制：声明一个私有的复制构造函数 <code>private: President(const President&amp;);</code></p>
<p>只能有一个实例的单例类：使用关键字 <code>static</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">President</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    private:</span><br><span class="line">        President() &#123;&#125;;  <span class="comment">// 私有的默认构造函数，防止外部创建实例</span></span><br><span class="line">        President(<span class="type">const</span> President&amp;);  <span class="comment">// 私有的拷贝构造函数，防止对象拷贝</span></span><br><span class="line">        <span class="type">const</span> President&amp; operator=(<span class="type">const</span> President);  <span class="comment">// 私有的赋值运算符重载，防止对象赋值</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> name;  <span class="comment">// 私有成员变量，用于存储总统的名字</span></span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        <span class="type">static</span> President&amp; <span class="title function_">GetInstance</span><span class="params">()</span>  <span class="comment">// 静态方法，用于获取唯一的实例</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">static</span> President onlyInstance;  <span class="comment">// 在首次调用时创建唯一实例</span></span><br><span class="line">            <span class="keyword">return</span> onlyInstance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> <span class="title function_">GetName</span><span class="params">()</span>  <span class="comment">// 公有方法，用于获取总统的名字</span></span><br><span class="line">        &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">void</span> <span class="title function_">SetName</span><span class="params">(<span class="built_in">string</span> InputName)</span>  <span class="comment">// 公有方法，用于设置总统的名字</span></span><br><span class="line">        &#123; name = InputName; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    President&amp; onlyPresident = President::GetInstance();  <span class="comment">// 获取 President 实例的引用</span></span><br><span class="line">    onlyPresident.SetName(<span class="string">&quot;Abraham Lincoln&quot;</span>);  <span class="comment">// 设置总统名字</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;President is: &quot;</span> &lt;&lt; President::GetInstance().GetName() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出总统名字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>禁止在栈中实例化的类(栈空间通常有限): 将析构函数声明为私有的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonsterDB</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">private: </span><br><span class="line"> ~MonsterDB(); <span class="comment">// private destructor </span></span><br><span class="line"> <span class="comment">//... members that consume a huge amount of data </span></span><br><span class="line">&#125;; </span><br><span class="line">通过声明私有的析构函数，可禁止像下面这样创建实例：</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line"> MonsterDB myDatabase; <span class="comment">// compile error </span></span><br><span class="line"> <span class="comment">// … more code </span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>使用构造函数进行类型转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"> <span class="type">int</span> age;  <span class="comment">// 私有成员变量 age，表示人的年龄</span></span><br><span class="line">public: </span><br><span class="line"> Human(<span class="type">int</span> humansAge): age(humansAge) &#123;&#125;  <span class="comment">// 构造函数，接受人的年龄作为参数并初始化成员变量 age</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Function that takes a Human as a parameter </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DoSomething</span><span class="params">(Human person)</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Human sent did something&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出信息</span></span><br><span class="line"> <span class="keyword">return</span>;  <span class="comment">// 返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> Human <span class="title function_">kid</span><span class="params">(<span class="number">10</span>)</span>;  <span class="comment">//利用构造函数显式转换：将整数 10 转换为 Human 类型对象</span></span><br><span class="line"> <span class="comment">//在这里，通过构造函数 Human(int humansAge) 创建了一个名为 kid 的 Human 类型对象，传递整数值 10 作为构造函数的参数。</span></span><br><span class="line"> <span class="comment">//这个构造函数被用来创建 Human 类型对象，并将整数 10 转换为 kid 的一个属性，即年龄</span></span><br><span class="line"> DoSomething(kid);  <span class="comment">// 调用 DoSomething 函数，将 kid 作为参数传递</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//隐式转换:</span></span><br><span class="line"> Human anotherKid = <span class="number">11</span>; <span class="comment">// int converted to Human </span></span><br><span class="line"> DoSomething(<span class="number">10</span>); <span class="comment">// 10 converted to Human! </span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//使用关键字 explicit 可禁止隐式转换，使上面两行编译失败:</span></span><br><span class="line"> explicit <span class="title function_">Human</span><span class="params">(<span class="type">int</span> humansAge)</span>: <span class="title function_">age</span><span class="params">(humansAge)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>this 指针</strong> :  在类中，关键字 this 包含当前对象的地址,当您在类成员方法中调用其他成员方法时，编译器将隐式地传递 this 指针—函数调用中不可见的参数<br><code>Talk(&quot;Bla bla&quot;); // same as Talk(this, &quot;Bla Bla&quot;) </code><br>*this表示当前对象的指针。它是一个特殊的指针，指向类的实例或对象自身</p>
<p><strong>sizeof( )</strong> ： 指出类声明中所有数据属性占用的总内存量，单位为字节 （结果受字填充word padding和其他因素的影响）</p>
<p><strong>关键字 struct</strong> 来自 C 语言，在 C++编译器看来，它与类极其相似，差别在于程序员未指定时，默认的访问限定符（public 和 private）不同，不同于结构，类的成员默认为私有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ Class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line">   <span class="type">bool</span> gender;</span><br><span class="line">   MyString name;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">   Human(<span class="type">const</span> MyString&amp; InputName, <span class="type">int</span> InputAge, <span class="type">bool</span> InputGender)</span><br><span class="line">      : name(InputName), age (InputAge), gender(InputGender) &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">GetAge</span> <span class="params">()</span></span><br><span class="line">   &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C struct, 除非指定了，否则结构中的成员默认为公有的, 另外，除非指定了，否则结构以公有方式继承基结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"> Human(<span class="type">const</span> MyString&amp; humansName, <span class="type">int</span> humansAge, <span class="type">bool</span> humansGender) </span><br><span class="line"> : name(humansName), age (humansAge), Gender(humansGender) &#123;&#125; </span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">GetAge</span> <span class="params">()</span> </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="keyword">return</span> age; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">private: </span><br><span class="line"> <span class="type">int</span> age; </span><br><span class="line"> <span class="type">bool</span> gender; </span><br><span class="line"> MyString name; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构 Human 与类 Human 很像；结构的实例化与类的实例化也很像：</span></span><br><span class="line">Human <span class="title function_">firstMan</span><span class="params">(<span class="string">&quot;Adam&quot;</span>, <span class="number">25</span>, <span class="literal">true</span>)</span>; <span class="comment">// an instance of struct Human</span></span><br></pre></td></tr></table></figure>

<p><strong>声明友元</strong>： 使用关键字 friend ，从外部访问类的私有数据成员和方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private: </span><br><span class="line">   friend <span class="type">void</span> <span class="title function_">DisplayAge</span><span class="params">(<span class="type">const</span> Human&amp; person)</span>; <span class="comment">//指出DisplayAge( )是 Human 类的友元，能够访问Human类的私有数据成员</span></span><br><span class="line">   <span class="comment">//friend class Utility; //指出 Utility 类是 Human 类的友元</span></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisplayAge</span><span class="params">(<span class="type">const</span> Human&amp; person)</span> </span><br><span class="line">   &#123; </span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; person.age &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>

<p><strong>共用体</strong>：使用关键字 union声明，是一种特殊的类，每次只有一个非静态数据成员处于活动状态。在结构中，常使用共用体来模拟复杂的数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">UnionName</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"> Type1 member1; </span><br><span class="line"> Type2 member2; </span><br><span class="line">…</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实例化并使用共用体：</span></span><br><span class="line">UnionName unionObject; </span><br><span class="line">unionObject.member2 = value; <span class="comment">// choose member2 as the active member</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在结构中，常使用共用体来模拟复杂的数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">ComplexType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">DataType</span> //使用枚举来存储信息类型</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Int,</span><br><span class="line">        Char</span><br><span class="line">    &#125;Type;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Value</span>   //使用共用体来存储实际值</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">char</span> alphabet;</span><br><span class="line"></span><br><span class="line">        Value() &#123;&#125;</span><br><span class="line">        ~Value() &#123;&#125;</span><br><span class="line">    &#125;value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>聚合初始化</strong>：即满足如下条件的类或结构为聚合类型，可作为一个整体进行初始化：只包含公有和非静态数据成员，而不包含私有或受保护的数据成员；不包含任何虚成员函数；只涉及公有继承（不涉及私有、受保护和虚拟继承）；不包含用户定义的构造函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Aggregate2</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"> <span class="type">int</span> num; </span><br><span class="line"> <span class="type">char</span> hello[<span class="number">6</span>]; </span><br><span class="line"> <span class="type">int</span> impYears[<span class="number">5</span>]; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//对于这个结构，可像下面这样进行初始化：</span></span><br><span class="line">Aggregate2 a2 &#123;<span class="number">42</span>, &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;, &#123;<span class="number">1998</span>, <span class="number">2003</span>, <span class="number">2011</span>, <span class="number">2014</span>, <span class="number">2017</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>定义常量表达式的关键字 <strong>constexpr</strong> 也可用于类和结果为常量的对象<br><code>constexpr Human(int humansAge) :age(humansAge) &#123;&#125;</code></p>
<h2 id="10-实现继承"><a href="#10-实现继承" class="headerlink" title="10.实现继承"></a>10.实现继承</h2><p>面向对象编程基于 4 个重要方面：封装、抽象、继承和多态。继承是一种强大的属性重用方式，是通向多态的跳板.</p>
<h3 id="继承和派生"><a href="#继承和派生" class="headerlink" title="继承和派生"></a>继承和派生</h3><p>继承: 从一个包含通用属性且实现了通用功能的基类（超类）派生出类似的类，并在派生类（子类）中覆盖基本功能，以实现让每个类都独一无二的行为。</p>
<p><strong>公有继承 public</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"> <span class="comment">// ... base class members </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public Base    <span class="comment">//public：公有继承，is-a关系，可通过派生类的对象来访问基类的公有成员</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// ... derived class members </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>基类初始化</strong> 向基类传递参数: 如果基类包含重载的构造函数，需要在实例化时给它提供实参,就使用初始化列表，并通过派生类的构造函数调用合适的基类构造函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">public: </span><br><span class="line"> Base(<span class="type">int</span> someNumber) <span class="comment">// overloaded constructor </span></span><br><span class="line"> &#123; </span><br><span class="line"> <span class="comment">// Use someNumber </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public Base </span><br><span class="line">&#123;</span><br><span class="line">public: </span><br><span class="line"> Derived(): Base(<span class="number">25</span>) <span class="comment">// instantiate Base with argument 25 </span></span><br><span class="line"> &#123; </span><br><span class="line"> <span class="comment">// derived class constructor code </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure>

<p><strong>覆盖基类</strong>: 派生类实现从基类继承的函数，且返回值和特征标相同的情况</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">public: </span><br><span class="line"> <span class="type">void</span> <span class="title function_">DoSomething</span><span class="params">()</span> </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="comment">// implementation code… Does something </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span>public Base </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line"> <span class="type">void</span> <span class="title function_">DoSomething</span><span class="params">()</span> </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="comment">// implementation code… Does something else </span></span><br><span class="line"> <span class="comment">//也可以用作用域解析运算符（::）在派生类中调用基类方法</span></span><br><span class="line">   Base::DoSomething   </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//调用基类中被覆盖的方法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   Derived test;</span><br><span class="line">   test.DoSomething();     <span class="comment">//被覆盖</span></span><br><span class="line">   test.Base::DoSomething; <span class="comment">//未覆盖，调用基类中的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐藏问题：覆盖可能导致派生类隐藏基类的所有重载版本，使调用重载产生编译错误（被隐藏）</span></span><br><span class="line"><span class="comment">//可使用关键字 using 避免隐藏基类方法</span></span><br></pre></td></tr></table></figure>
<p>构造顺序：基类对象在派生类对象之前被实例化，实例化时，先实例化成员属性，再调用构造函数；析构顺序正好相反。</p>
<p><strong>私有继承 private</strong><br>私有继承使得只有子类才能使用基类的属性和方法，继承派生类的类不能访问基类的成员, 因此也被称为 <em>has-a</em> 关系, 指定派生类的基类时使用关键字 private：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"> <span class="comment">// ... base class members and methods </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> private Base <span class="comment">// private inheritance  类的继承关系默认为私有</span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// ... derived class members and methods </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p><strong>保护继承 protected</strong><br>继承派生类的类能够访问基类的公有和保护方法，但不能通过派生类的对象来访问基类的公有成员；<br>使用访问限定符 protected: 对需要继承的基类属性进行保护,让基类的某些属性能在派生类中访问，但不能在继承层次结构外部访问</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> protected Base</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//子类的子类能够访问 Base 类的公有和保护成员:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived2</span>:</span> protected Derived </span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// can access public &amp; protected members of Base </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>切除（slicing）问题: 复制对象时不要按值传递参数，而应以指向基类的指针或 const 引用的方式传递</p>
<p>多继承: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public Base1, publice Base2 </span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// class members </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 final 禁止继承: <code>class Derived final: public Base1, publice Base2 </code></p>
<blockquote>
<p>要建立 is-a 关系，务必创建公有继承层次结构。<br>要建立 has-a 关系，务必创建私有或保护继承层次结构。(仅当必要时才使用私有或保护继承)<br>无论继承关系是什么，派生类都不能访问基类的私有成员。一个例外是类的友元函数和友元类</p>
</blockquote>
<h2 id="11-多态"><a href="#11-多态" class="headerlink" title="11.多态"></a>11.多态</h2><p>面向对象编程的核心——多态<br>多态：将派生类对象视为基类对象，并执行派生类的实现</p>
<p><strong>虚函数 virtual</strong><br>使用虚函数实现多态行为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"> virtual ReturnType <span class="title function_">FunctionName</span> <span class="params">(Parameter List)</span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"> ReturnType <span class="title function_">FunctionName</span> <span class="params">(Parameter List)</span>; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>使用关键字 virtual, Swim( )被声明为虚函数，确保编译器调用覆盖版本<br>对于将被派生类覆盖的基类方法，务必将其声明为虚函数。</p>
<p>作用：对于使用 new 在自由存储区中实例化的派生类对象，如果将其赋给基类指针，并通过该指针调用 delete，将不会调用派生类的析构函数。这可能导致资源未释放、内存泄露等问题，因此可将<strong>析构函数声明为虚函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">public: </span><br><span class="line"> virtual ~Base() &#123;&#125;; <span class="comment">// virtual destructor </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p><strong>抽象基类和纯虚函数</strong><br>不能实例化的基类被称为抽象基类，这样的基类只有一个用途，那就是从它派生出其他类（充当接口）。在 C++中，要创建抽象基类，可声明纯虚函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractBase</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">public: </span><br><span class="line"> virtual <span class="type">void</span> <span class="title function_">DoSomething</span><span class="params">()</span> = <span class="number">0</span>; <span class="comment">// pure virtual method </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//该声明告诉编译器，AbstractBase 的派生类必须实现方法 DoSomething()：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> public AbstractBase </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line"> <span class="type">void</span> <span class="title function_">DoSomething</span><span class="params">()</span> <span class="comment">// pure virtual fn. must be implemented </span></span><br><span class="line"> &#123; </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Implemented virtual function&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>抽象基类提供了一种非常好的机制，能够声明所有派生类都必须实现的函数。如果 Trout 类从Fish 类派生而来，但没有实现 Trout::Swim( )，将无法通过编译</p>
<p><strong>虚继承 virtual</strong><br>使用<strong>虚继承</strong>解决菱形问题：在继承层次结构中，继承多个从同一个类派生而来的基类时，如果这些基类没有采用虚继承，将导致二义性，因此，如果派生类可能被用作基类，派生时最好使用<em>虚继承</em>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived1</span>:</span> public virtual Base </span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">// ... members and functions </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>用于创建继承层次结构和声明基类函数时，关键字 virtual 的作用不同:<br>在函数声明中，virtual 意味着当基类指针指向派生对象时，通过它可调用派生类的相应函数。<br>从 Base 类派生出 Derived1 和 Derived2 类时，如果使用了关键字 virtual，则意味着再从Derived1 和 Derived2 派生出 Derived3 时，每个 Derived3 实例只包含一个 Base 实例。</p>
</blockquote>
<p>表明覆盖意图的限定符 <strong>override</strong> , 来核实被覆盖的函数在基类中是否被声明为虚的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuna</span>:</span>public Fish </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line"> <span class="type">void</span> <span class="title function_">Swim</span><span class="params">()</span> <span class="type">const</span> override <span class="comment">// Error: no virtual fn with this sig in Fish </span></span><br><span class="line"> &#123; </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tuna swims!&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>在派生类中声明要覆盖基类函数的函数时，务必使用关键字 override。</p>
<p>使用 <strong>final</strong> 来禁止覆盖函数, 被声明为 final 的虚函数，不能在派生类中进行覆盖</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuna</span>:</span>public Fish </span><br><span class="line">&#123; </span><br><span class="line">public: </span><br><span class="line"> <span class="type">void</span> <span class="title function_">Swim</span><span class="params">()</span> override final  <span class="comment">// override Fish::Swim and make this final </span></span><br><span class="line"> &#123; </span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tuna swims!&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;;<span class="comment">//可继承这个版本的 Tuna 类，但不能进一步覆盖函数 Swim()</span></span><br></pre></td></tr></table></figure>

<p>虚函数 Clone 模拟虚复制构造函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>        <span class="comment">//头文件</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;     <span class="comment">//名称空间</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>     //定义<span class="title">Fish</span>类作为基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   public:</span><br><span class="line">      virtual Fish* <span class="title function_">Clone</span><span class="params">()</span>=<span class="number">0</span>;   <span class="comment">//声明一个纯虚函数Clone 用于克隆对象</span></span><br><span class="line">      virtual <span class="type">void</span> <span class="title function_">Swim</span><span class="params">()</span>=<span class="number">0</span>;     <span class="comment">//声明一个纯虚函数Swim</span></span><br><span class="line">      virtual ~Fish() &#123;&#125;;     <span class="comment">//声明虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuna</span>:</span> public Fish    <span class="comment">//定义Tuna类，继承自Fish</span></span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      Fish* <span class="title function_">Clone</span><span class="params">()</span> override  <span class="comment">//实现Clone函数，返回一个克隆对象指针</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> new Tuna (*this);   <span class="comment">//*this表示当前对象的指针</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> <span class="title function_">Swim</span><span class="params">()</span> override final <span class="comment">//final使它的派生类无法覆盖swim</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Tuna swims fast in the sea&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BluefinTuna</span> <span class="keyword">final</span>:</span>public Tuna <span class="comment">// 定义BluefinTuna类，继承自Tuna</span></span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      Fish* <span class="title function_">Clone</span><span class="params">()</span> override  <span class="comment">//无法覆盖Tuna类中的Swim函数</span></span><br><span class="line">      &#123;<span class="comment">//调用 Swim()时执行 Tuna::Swim()</span></span><br><span class="line">         <span class="keyword">return</span> new BluefinTuna(*this);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Carp</span> <span class="keyword">final</span>:</span> public Fish <span class="comment">// 定义Carp类，继承自Fish</span></span><br><span class="line">&#123;</span><br><span class="line">   Fish* <span class="title function_">Clone</span><span class="params">()</span> override&#123;</span><br><span class="line">      <span class="keyword">return</span> new Carp(*this);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">void</span> <span class="title function_">Swim</span><span class="params">()</span> override final  <span class="comment">// 实现Carp的Swim函数</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Carp swims slow in the lake&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> ARRAY_SIZE =<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">   Fish* myFishes[ARRAY_SIZE]=&#123;<span class="literal">NULL</span>&#125;;  <span class="comment">//声明静态基类指针（Fish *）数组，创建对象</span></span><br><span class="line">   myFishes[<span class="number">0</span>]=new Tuna();</span><br><span class="line">   myFishes[<span class="number">1</span>]=new Carp();</span><br><span class="line">   myFishes[<span class="number">2</span>]=new BluefinTuna();</span><br><span class="line">   myFishes[<span class="number">3</span>]=new Carp();</span><br><span class="line"></span><br><span class="line">   Fish* myNewFishes[ARRAY_SIZE];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> index=<span class="number">0</span>; index &lt; ARRAY_SIZE; ++index)</span><br><span class="line">      myNewFishes[index]=myFishes[index]-&gt;Clone(); <span class="comment">// 使用Clone函数克隆原对象到另一个数组</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> index=<span class="number">0</span>; index&lt;ARRAY_SIZE; ++index)</span><br><span class="line">      myNewFishes[index]-&gt;Swim();   <span class="comment">// 调用克隆对象的Swim函数，以验证 Clone( )复制了整个派生类对象</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> index=<span class="number">0</span>; index&lt;ARRAY_SIZE; ++index)</span><br><span class="line">      &#123;  <span class="comment">// 释放内存</span></span><br><span class="line">         delete myFishes[index];</span><br><span class="line">         delete myNewFishes[index];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>














<hr>
<hr>
<h1 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h1><p><a href="www.cmake.org">CMake</a> 是一个跨平台的开源构建管理系统，用于自动化应用程序的构建、测试和打包过程。它使用类似于Makefile的文本文件来描述构建过程中所需的所有组件和依赖项，并将其转换为适合各种不同编译器和操作系统的本地构建系统的配置文件。总之，CMake就是一个将多个cpp,hpp文件组合构建为一个大工程的语言。<br><a target="_blank" rel="noopener" href="https://cmake.org/download/">CMake下载</a> (Linux无需下载)<br><a target="_blank" rel="noopener" href="https://github.com/gavinliu6/CMake-Practice-zh-CN">Cmake 实践</a> 在实践中上手的教程<br><a target="_blank" rel="noopener" href="https://github.com/SFUMECJF/cmake-examples-Chinese">cmake-examples-Chinese</a> 例程</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Arrowes/C-coding/tree/main/Cmake">C-coding&#x2F;Cmake at main · Arrowes&#x2F;C-coding</a></p>
<h2 id="Cmake-实践"><a href="#Cmake-实践" class="headerlink" title="Cmake 实践"></a><a target="_blank" rel="noopener" href="https://gavinliu6.github.io/CMake-Practice-zh-CN/#/">Cmake 实践</a></h2><h3 id="t1-创建Hello-world"><a href="#t1-创建Hello-world" class="headerlink" title="t1 创建Hello world"></a>t1 <a target="_blank" rel="noopener" href="https://github.com/gavinliu6/CMake-Practice-zh-CN/blob/master/hello-world.md">创建Hello world</a></h3><p>建立main.c与CMakeLists.txt并编译（需要为每一个子目录建立一个CMakeLists.txt）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PROJECT (HELLO)     <span class="comment">#PROJECT(projectname [CXX] [C] [Java])</span></span><br><span class="line">SET(SRC_LIST main.c)    <span class="comment">#提供要编译的源代码文件列表，可定义多个源文件main.c 1.c</span></span><br><span class="line">MESSAGE([SEND_ERROR|STATUS|FATAL_ERROR] <span class="string">&quot;message to display&quot;</span>)</span><br><span class="line">ADD_EXECUTABLE(hello <span class="variable">$&#123;SRC_LIST&#125;</span>)   <span class="comment">#创建名为hello的可执行文件，IF不用$&#123;&#125;引用变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#内部编译(在文件夹中产生文件太多)</span></span><br><span class="line">cmake . <span class="comment">#构建工程，生成makefile</span></span><br><span class="line">make    <span class="comment">#构建目标文件hello二进制</span></span><br><span class="line">./hello <span class="comment">#运行目标文件</span></span><br><span class="line"><span class="comment">#外部编译(out of source build,推荐)</span></span><br><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build <span class="comment">#新建并进入build文件夹</span></span><br><span class="line">cmake ..    <span class="comment">#在父目录找到cmakelists构建工程</span></span><br><span class="line">make    <span class="comment">#在build编译目录中获得目标文件，不影响原有工程</span></span><br></pre></td></tr></table></figure>
<p>目标文件:在linux下，是ELF格式（Executable Linkable Format，可执行可链接格式），而在windows下是PE（Portable Executable，可移植可执行）。通常有三种形式：</p>
<ul>
<li>可执行目标文件。即我们通常所认识的，可直接运行的二进制文件。</li>
<li>可重定位目标文件。包含了二进制的代码和数据，可以与其他可重定位目标文件合并，并创建一个可执行目标文件。</li>
<li>共享目标文件。它是一种在加载或者运行时进行链接的特殊可重定位目标文件。</li>
</ul>
<h3 id="t2-完善项目并安装"><a href="#t2-完善项目并安装" class="headerlink" title="t2 完善项目并安装"></a>t2 <a target="_blank" rel="noopener" href="https://github.com/gavinliu6/CMake-Practice-zh-CN/blob/master/better-hello-world.md">完善项目并安装</a></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在CMakeLists中加入</span></span><br><span class="line">ADD_SUBDIRECTORY(src bin) <span class="comment">#把src子目录加入工程，编译输出路径为bin</span></span><br><span class="line">INSTALL(FILES COPYRIGHT README DESTINATION doc)</span><br><span class="line">INSTALL(PROGRAMS runhello.sh DESTINATION bin)</span><br><span class="line">INSTALL(DIRECTORY doc/ DESTINATION doc) <span class="comment">#不同的安装类型</span></span><br><span class="line"><span class="comment">#在 src的 CMakeLists.txt中添加，以安装hello到bin中</span></span><br><span class="line">INSTALL(TARGETS hello RUNTIME DESTINATION bin) </span><br><span class="line"></span><br><span class="line"><span class="comment">#Install</span></span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=tmp ..</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h3 id="t3-lib静态库和动态库构建"><a href="#t3-lib静态库和动态库构建" class="headerlink" title="t3 lib静态库和动态库构建"></a>t3 <a target="_blank" rel="noopener" href="https://github.com/gavinliu6/CMake-Practice-zh-CN/blob/master/static-and-dynamic.md">lib静态库和动态库构建</a></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SET(LIBHELLO_SRC hello.c)</span><br><span class="line">ADD_LIBRARY(hello SHARED <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)   <span class="comment">#SHARED动态库（.so）</span></span><br><span class="line">ADD_LIBRARY(hello_static STATIC <span class="variable">$&#123;LIBHELLO_SRC&#125;</span>)    <span class="comment">#STATIC静态库(.a) </span></span><br><span class="line">SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)  <span class="comment">#设置静态库名称，以得到名字相同的.so .a</span></span><br><span class="line">SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1) <span class="comment">#动态库版本号 </span></span><br><span class="line">INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib) <span class="comment">#关键字ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制</span></span><br><span class="line">INSTALL(FILES hello.h DESTINATION include/hello)</span><br></pre></td></tr></table></figure>
<p>静态库.a（Static Library），所有函数和数据都在编译时被静态链接到可执行文件中。文件较大，但不容易受到环境变量和库版本变化的影响，能够提供更好的性能和稳定性。<br>动态库.so（Dynamic Library）（共享库），在程序运行时才被加载到内存中，而不是在程序编译时被静态链接到可执行文件中，每个动态库只需要一个副本，可以供多个程序使用，因此可以减小可执行文件的大小，减少内存占用，并且如果库文件更新，则只需要替换动态库文件即可，但由于需要在运行时加载库文件，因此可能会稍微降低程序的启动和运行速度。</p>
<h3 id="t4-使用外部共享库和头文件"><a href="#t4-使用外部共享库和头文件" class="headerlink" title="t4 使用外部共享库和头文件"></a>t4 <a target="_blank" rel="noopener" href="https://github.com/gavinliu6/CMake-Practice-zh-CN/blob/master/the-use-of-lib-and-header-file.md">使用外部共享库和头文件</a></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在src/CMakeLists.txt中添加头文件.h搜索路径</span></span><br><span class="line">INCLUDE_DIRECTORIES(XXX/include/hello)</span><br><span class="line">TARGET_LINK_LIBRARIES(main XXX/lib/libhello.so) <span class="comment">#添加共享库链接</span></span><br><span class="line"><span class="comment">#若要链接静态库：TARGET_LINK_LIBRARIES(main XXX/lib/libhello.a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行ldd查看链接情况</span></span><br><span class="line">ldd src/main</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改环境变量，在bash中运行：</span></span><br><span class="line"><span class="built_in">export</span> CMAKE_INCLUDE_PATH=XXX/include/hello <span class="comment">#然后利用FIND_PATH相关指令替换INCLUDE_DIRECTORIES</span></span><br></pre></td></tr></table></figure>
<h3 id="常用变量与环境变量"><a href="#常用变量与环境变量" class="headerlink" title="常用变量与环境变量"></a><a target="_blank" rel="noopener" href="https://github.com/gavinliu6/CMake-Practice-zh-CN/blob/master/common-var.md">常用变量与环境变量</a></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#常用变量</span></span><br><span class="line">CMAKE_BINARY_DIR    <span class="comment">#如果是 in source 编译，指工程顶层目录，如果是 out-of-source 编译，指工程编译发生的目录,还有PROJECT_BINARY_DIR，&lt;projectname&gt;_BINARY_DIR</span></span><br><span class="line">CMAKE_SOURCE_DIR    <span class="comment">#工程顶层目录，PROJECT_SOURCE_DIR，&lt;projectname&gt;_SOURCE_DIR</span></span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR    <span class="comment">#当前处理的 CMakeLists.txt 所在的路径</span></span><br><span class="line">CMAKE_CURRRENT_BINARY_DIR   <span class="comment">#若是 in-source 编译，同上一致，对out-ofsource 编译，他指的是 target 编译目录。</span></span><br><span class="line">CMAKE_CURRENT_LIST_FILE <span class="comment">#输出调用这个变量的 CMakeLists.txt 的完整路径</span></span><br><span class="line">CMAKE_CURRENT_LIST_LINE <span class="comment">#输出这个变量所在的行</span></span><br><span class="line">CMAKE_MODULE_PATH       <span class="comment">#定义自己的 cmake 模块所在的路径</span></span><br><span class="line">EXECUTABLE_OUTPUT_PATH，LIBRARY_OUTPUT_PATH <span class="comment">#分别用来重新定义最终结果的存放目录，如SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)</span></span><br><span class="line">PROJECT_NAME    <span class="comment">#返回通过 PROJECT 指令定义的项目名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#环境变量，使用$ENV&#123;NAME&#125; 调用系统环境变量</span></span><br><span class="line">SET(ENV&#123;变量名&#125; 值) <span class="comment">#设置环境变量</span></span><br><span class="line">    CMAKE_INCLUDE_CURRENT_DIR</span><br><span class="line">    CMAKE_INCLUDE_DIRECTORIES_PROJECT_BEFORE</span><br><span class="line">    CMAKE_INCLUDE_PATH，CMAKE_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<h3 id="cmake常用指令"><a href="#cmake常用指令" class="headerlink" title="cmake常用指令"></a><a target="_blank" rel="noopener" href="https://github.com/gavinliu6/CMake-Practice-zh-CN/blob/master/common-directives.md">cmake常用指令</a></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make VERBOSE=1  <span class="comment">#查看make过程</span></span><br><span class="line">make clean  <span class="comment">#清理工程</span></span><br></pre></td></tr></table></figure>
<h3 id="t5-t6-模块"><a href="#t5-t6-模块" class="headerlink" title="t5,t6 模块"></a><a target="_blank" rel="noopener" href="https://github.com/gavinliu6/CMake-Practice-zh-CN/blob/master/module.md">t5,t6 模块</a></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#系统预定义的模块</span></span><br><span class="line">FIND_PACKAGE(CURL)  <span class="comment">#FindCURL模块</span></span><br><span class="line">IF(CURL_FOUND)  <span class="comment">#判断模块是否被找到</span></span><br><span class="line">   INCLUDE_DIRECTORIES(<span class="variable">$&#123;CURL_INCLUDE_DIR&#125;</span>)</span><br><span class="line">   TARGET_LINK_LIBRARIES(curltest <span class="variable">$&#123;CURL_LIBRARY&#125;</span>)</span><br><span class="line">ELSE(CURL_FOUND)</span><br><span class="line">     MESSAGE(FATAL_ERROR ”CURL library not found”)</span><br><span class="line">ENDIF(CURL_FOUND)</span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义FindHELLO模块</span></span><br><span class="line">FIND_PATH(HELLO_INCLUDE_DIR hello.h /usr/include/hello /usr/local/include/hello)    <span class="comment"># 在指定目录中搜索hello.h文件</span></span><br><span class="line">FIND_LIBRARY(HELLO_LIBRARY NAMES hello PATH /usr/lib /usr/local/lib)    <span class="comment"># 在指定目录中搜索名为hello的库文件</span></span><br><span class="line">IF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY) <span class="comment"># 如果找到了头文件和库，则标记为HELLO_FOUND</span></span><br><span class="line">   SET(HELLO_FOUND TRUE)</span><br><span class="line">ENDIF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY)</span><br><span class="line">IF(HELLO_FOUND) <span class="comment"># 如果找到了头文件和库，则输出一个消息</span></span><br><span class="line">   IF(NOT HELLO_FIND_QUIETLY)   <span class="comment">#如果没有被标记为“安静模式”，则输出</span></span><br><span class="line">       MESSAGE(STATUS <span class="string">&quot;Found Hello: <span class="variable">$&#123;HELLO_LIBRARY&#125;</span>&quot;</span>)</span><br><span class="line">   ENDIF(NOT HELLO_FIND_QUIETLY)</span><br><span class="line">ELSE(HELLO_FOUND)   <span class="comment"># 如果没有找到，并且被标记为必需，则输出错误信息</span></span><br><span class="line">   IF(HELLO_FIND_REQUIRED)  <span class="comment">#如果被标记为“必需”，则输出致命错误消息</span></span><br><span class="line">      MESSAGE(FATAL_ERROR <span class="string">&quot;Could not find hello library&quot;</span>)</span><br><span class="line">   ENDIF(HELLO_FIND_REQUIRED)</span><br><span class="line">ENDIF(HELLO_FOUND)</span><br></pre></td></tr></table></figure>
<h2 id="Cmake-Opencv-Demo"><a href="#Cmake-Opencv-Demo" class="headerlink" title="Cmake Opencv Demo"></a>Cmake Opencv Demo</h2><p><strong>1.安装OpenCV</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/opencv/opencv.git</span><br><span class="line"><span class="built_in">cd</span> opencv</span><br><span class="line"><span class="comment">#cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local ..   #cmake把opencv的一些库和可执行文件安装到系统目录下 需要权限</span></span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/opencv .. <span class="comment">#本地安装无需权限</span></span><br><span class="line">make -j8 <span class="comment">#使用8个线程进行编译,否则很久</span></span><br><span class="line">make install   <span class="comment">#安装库文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置OpenCV环境变量</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/ywang85/opencv/lib:<span class="variable">$LD_LIBRARY_PATH</span>  <span class="comment">#链接库文件</span></span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=/home/ywang85/opencv/lib/cmake/opencv4/:<span class="variable">$PKG_CONFIG_PATH</span>  <span class="comment">#链接配置文件</span></span><br></pre></td></tr></table></figure>
<p><strong>2.写主程序</strong></p>
<details>
  <summary>边缘提取程序</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> threshold_value = <span class="number">100</span>, threshold_max = <span class="number">255</span>;</span><br><span class="line"><span class="type">int</span> threshold_type = <span class="number">0</span>, threshold_type_max = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">string</span> outwindow = <span class="string">&quot;threshold img&quot;</span>;</span><br><span class="line">Mat src, dst;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   Mat src1;</span><br><span class="line">   src1 = imread(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">   resize(src1, src, Size(src1.cols, src1.rows)); </span><br><span class="line">   <span class="comment">//resize(src1, src, Size(src1.cols/2, src1.rows/2)); //缩小一半</span></span><br><span class="line">   <span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;cannot load image ...&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Mat src_gray;</span><br><span class="line">   cvtColor(src, src_gray, COLOR_BGR2GRAY);</span><br><span class="line">   Canny(src_gray, dst, <span class="number">100</span>, <span class="number">200</span>);<span class="comment">//canny边缘检测算子</span></span><br><span class="line">   imwrite(<span class="string">&quot;canny.jpg&quot;</span>, dst);</span><br><span class="line">   imwrite(<span class="string">&quot;canny2.jpg&quot;</span>, ~dst); <span class="comment">//dst按照像素值取反</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>使用OpenCV的canny算子检测边缘</p>
<p><strong>3.写CMake</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">2.8</span>)</span><br><span class="line">project(EDGE)</span><br><span class="line"><span class="built_in">set</span>(OpenCV_DIR <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/opencv/lib/cmake/opencv4/&quot;</span>) #设置 OpenCV 的 CMake 路径</span><br><span class="line">find_package(OpenCV REQUIRED)</span><br><span class="line">add_executable(EDGE main.cpp)</span><br><span class="line">target_include_directories(EDGE PUBLIC $&#123;OpenCV_INCLUDE_DIRS&#125;)  #头文件路径添加到编译器的include路径中</span><br><span class="line">target_link_libraries(EDGE PUBLIC $&#123;OpenCV_LIBS&#125;)   #链接OpenCV库</span><br><span class="line">#需要注意opencv库的链接</span><br></pre></td></tr></table></figure>
<p><strong>4.编译运行</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake ..</span><br><span class="line">make  #生成可执行文件</span><br><span class="line">./EDGE   #运行边缘提取执行文件</span><br></pre></td></tr></table></figure>
<img data-src="https://raw.gitmirror.com/Arrowes/Blog/main/images/Cedge.png" width="50%">


<h2 id="基于VScode用cmake搭建C-编译调试环境"><a href="#基于VScode用cmake搭建C-编译调试环境" class="headerlink" title="基于VScode用cmake搭建C++编译调试环境"></a>基于VScode用cmake搭建C++编译调试环境</h2><ol>
<li>安装VScode插件：C&#x2F;C++，cmake，cmake tools</li>
<li>按F1，选择cmake:Quick Start,创建一个cmake工程</li>
<li>点击左侧栏的CMake工具按钮,右键可执行文件，选择Debug,进入调试界面</li>
</ol>
<h2 id="gcc-g-MinGW-MSVC与make-CMake-qmake"><a href="#gcc-g-MinGW-MSVC与make-CMake-qmake" class="headerlink" title="gcc&#x2F;g++,MinGW&#x2F;MSVC与make&#x2F;CMake&#x2F;qmake"></a>gcc&#x2F;g++,MinGW&#x2F;MSVC与make&#x2F;CMake&#x2F;qmake</h2><p><strong>GNU</strong>&#x2F;Linux：简称Linux，包括Ubuntu，Debian，CentOS，自带gcc；<br><strong>gcc&#x2F;g++</strong> ：GNU编译器套件（GNU Compiler Collection）,在<em>Linux</em>或MacOS上使用，gcc主要用于C语言,g++支持更多的C++特性。</p>
<p><strong>MinGW</strong>(Minimalist GNUfor Windows)，是<em>Windows</em>下运行的GNU环境，包含gcc和一系列工具，让开发者在Windows下可以写GNU的c&#x2F;c++代码, 编译的结果是windows的可执行文件exe；<br><strong>MSVC</strong>:微软开发的C&#x2F;C++编译器，在<em>Windows</em>下编译C&#x2F;C++程序。它被集成在Visual Studio IDE中。</p>
<p><strong>Makefile</strong>包含了描述如何编译和链接程序的规则和指令,指定哪些文件需要先编译，后编译以及重新编译，甚至更复杂的功能操作,通常被用于自动化构建C&#x2F;C++项目;<br><strong>Make</strong>是一个自动化构建工具，执行Make命令时，它会读取Makefile中的规则，并根据依赖项关系来判断哪些规则需要被执行，来实现编译、链接等操作。<br><strong>CMake</strong>是一个跨平台的自动化构建工具，与Make类似，但是它不直接构建项目，而是生成适合不同构建系统的配置文件，如Makefile或Visual Studio的.sln文件，并调用相应的构建系统来进行项目构建。<br><strong>qmake</strong>是Qt框架提供的自动化构建工具，用于构建Qt项目。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Paper/" rel="prev" title="Paper：科研方法总结">
      <i class="fa fa-chevron-left"></i> Paper：科研方法总结
    </a></div>
      <div class="post-nav-item">
    <a href="/TDA4VM/" rel="next" title="TDA4①：SDK, TIDL, OpenVX">
      TDA4①：SDK, TIDL, OpenVX <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C"><span class="nav-number">1.</span> <span class="nav-text">C</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-1"><span class="nav-number">2.</span> <span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%BB%AA%E8%AE%BA"><span class="nav-number">2.1.</span> <span class="nav-text">1.绪论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">2.2.</span> <span class="nav-text">2.C++程序的组成部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="nav-number">2.3.</span> <span class="nav-text">3.使用变量和常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">2.3.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">2.3.2.</span> <span class="nav-text">常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%AE%A1%E7%90%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.4.</span> <span class="nav-text">4.管理数组和字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.4.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">2.4.2.</span> <span class="nav-text">字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%BD%BF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E8%AF%AD%E5%8F%A5%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.5.</span> <span class="nav-text">5.使用表达式、语句和运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B"><span class="nav-number">2.6.</span> <span class="nav-text">6.控制程序流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C"><span class="nav-number">2.6.1.</span> <span class="nav-text">条件执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C"><span class="nav-number">2.6.2.</span> <span class="nav-text">循环执行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81"><span class="nav-number">2.7.</span> <span class="nav-text">7.使用函数组织代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="nav-number">2.7.1.</span> <span class="nav-text">函数数据处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">2.7.2.</span> <span class="nav-text">微处理器如何处理函数调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E9%98%90%E8%BF%B0%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">2.8.</span> <span class="nav-text">8.阐述指针和引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">2.8.1.</span> <span class="nav-text">指针 *</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">2.8.2.</span> <span class="nav-text">引用 &amp;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.9.</span> <span class="nav-text">9.类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.9.1.</span> <span class="nav-text">类和对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-public-%E5%92%8C-private"><span class="nav-number">2.9.2.</span> <span class="nav-text">关键字 public 和 private</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.9.3.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.9.4.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.9.5.</span> <span class="nav-text">复制构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B6%E4%BB%96%E7%94%A8%E9%80%94"><span class="nav-number">2.9.6.</span> <span class="nav-text">构造函数和析构函数的其他用途</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="nav-number">2.10.</span> <span class="nav-text">10.实现继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F"><span class="nav-number">2.10.1.</span> <span class="nav-text">继承和派生</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E5%A4%9A%E6%80%81"><span class="nav-number">2.11.</span> <span class="nav-text">11.多态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cmake"><span class="nav-number">3.</span> <span class="nav-text">Cmake</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Cmake-%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.1.</span> <span class="nav-text">Cmake 实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#t1-%E5%88%9B%E5%BB%BAHello-world"><span class="nav-number">3.1.1.</span> <span class="nav-text">t1 创建Hello world</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#t2-%E5%AE%8C%E5%96%84%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%AE%89%E8%A3%85"><span class="nav-number">3.1.2.</span> <span class="nav-text">t2 完善项目并安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#t3-lib%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E6%9E%84%E5%BB%BA"><span class="nav-number">3.1.3.</span> <span class="nav-text">t3 lib静态库和动态库构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#t4-%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%85%B1%E4%BA%AB%E5%BA%93%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">3.1.4.</span> <span class="nav-text">t4 使用外部共享库和头文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">3.1.5.</span> <span class="nav-text">常用变量与环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cmake%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.6.</span> <span class="nav-text">cmake常用指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#t5-t6-%E6%A8%A1%E5%9D%97"><span class="nav-number">3.1.7.</span> <span class="nav-text">t5,t6 模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cmake-Opencv-Demo"><span class="nav-number">3.2.</span> <span class="nav-text">Cmake Opencv Demo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EVScode%E7%94%A8cmake%E6%90%AD%E5%BB%BAC-%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="nav-number">3.3.</span> <span class="nav-text">基于VScode用cmake搭建C++编译调试环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gcc-g-MinGW-MSVC%E4%B8%8Emake-CMake-qmake"><span class="nav-number">3.4.</span> <span class="nav-text">gcc&#x2F;g++,MinGW&#x2F;MSVC与make&#x2F;CMake&#x2F;qmake</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Arrow</p>
  <div class="site-description" itemprop="description">记录一些杂七杂八的东西</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Arrowes" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Arrowes" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:395841716@qq.com" title="E-Mail → mailto:395841716@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/wangyujie.site" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;wangyujie.site" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/Arrowes?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;Arrowes?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/23930762?spm_id_from=333.1007.0.0" title="bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;23930762?spm_id_from&#x3D;333.1007.0.0" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>bilibili</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://oshwhub.com/arrows" title="立创EDA → https:&#x2F;&#x2F;oshwhub.com&#x2F;arrows" rel="noopener" target="_blank"><i class="fa fa-microchip fa-fw"></i>立创EDA</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arrow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">74k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:30</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>











<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '0cf14e51c1582cf64289',
      clientSecret: '5e8273d27714e40495267c73e607cfe9322b7266',
      repo        : 'Arrowes.github.io',
      owner       : 'Arrowes',
      admin       : ['Arrowes'],
      id          : '53fac62d9fcefc5967b52929c0915039',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
